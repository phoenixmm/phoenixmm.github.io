{"pages":[],"posts":[{"title":"Hello World","text":"Quick Start Create a new post Run server Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/08/07/hello-world/"},{"title":"test html md","text":"test html md test html title 1 a 1 a 1 a 1 a 2 a 2 a 2 a","link":"/2019/08/08/test html md/"},{"title":"hexo+githubda搭建个人博客教程","text":"前言使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 等等； 前言 准备工作 搭建github博客 创建仓库 绑定域名 配置SSH key 测试是否成功 使用hexo写博客 hexo简介 原理 注意事项 安装 初始化 修改主题 上传之前 上传到github 保留CNAME、README.md等文件 常用hexo命令 写博客 写博客工具 如何让博文列表不显示全部内容 准备工作在开始一切之前，你必须已经： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端） 本文所使用的环境： Windows8.1 node.js@5.5.0 git@1.9.2 hexo@3.2.2 搭建github博客创建仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 绑定域名当然，你不绑定域名肯定也是可以的，就用默认的 xxx.github.io 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。 首先你要注册一个域名，域名注册以前总是推荐去godaddy，现在觉得其实国内的阿里云也挺不错的，价格也不贵，毕竟是大公司，放心！ 绑定域名分2种情况：带www和不带www的。 域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问，如下： 然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试： 如果你填写的是没有www的，比如 mygit.me，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://mygit.me 如果你填写的是带www的，比如 www.mygit.me ，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://www.mygit.me 如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 http://abc.mygit.me 没问题，但是访问 http://mygit.me ，不会自动跳转到 http://abc.mygit.me 另外说一句，在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。 配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 $ cd ~/. ssh #检查本机已存在的ssh密钥如果提示：No such file or directory 说明你是第一次使用git。 ssh-keygen -t rsa -C &quot;邮件地址&quot;然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将刚复制的内容粘贴到key那里，title随便填，保存。 测试是否成功$ ssh -T git@github.com # 注意邮箱地址不用改如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 使用hexo写博客hexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.iogithub: https://github.com/hexojs/hexo 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 注意事项安装之前先来说几个注意事项： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 安装$ npm install -g hexo初始化在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是F:\\Workspaces\\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 $ cd /f/Workspaces/hexo/ $ hexo inithexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： $ hexo g # 生成 $ hexo s # 启动服务执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章： http://blog.liuxianan.com/windows-port-bind.html 第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑，打开时就是这个样子： 修改主题既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。 个人比较喜欢的2个主题：hexo-theme-jekyll 和 hexo-theme-yilia。 首先下载这个主题： $ cd /f/Workspaces/hexo/ $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia下载后的主题都在这里： 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 上传之前在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。 首先，ssh key肯定要配置好。 其次，配置_config.yml中有关deploy的部分： deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git branch: master此时直接执行hexo d的话一般会报如下错误： Deployer not found: github 或者 Deployer not found: git原因是还需要安装一个插件： npm install hexo-deployer-git --save其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey). 保留CNAME、README.md等文件提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的： 由于hexo默认会把所有md文件都转换成html，包括READM.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。 常用hexo命令常见命令 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本缩写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy组合命令： hexo s -g #生成并本地预览 hexo d -g #生成并上传_config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。 需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 写博客定位到我们的hexo根目录，执行命令： hexo new &apos;my-first-blog&apos;hexo会帮我们在_posts下生成相关md文件： 我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： 当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。 一般完整格式如下： --- title: postName #文章页面上的显示名称，一般是中文 date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改 categories: 默认分类 #分类 tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格 description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面 --- 以下是正文那么hexo new page 'postName'命令和hexo new 'postName'有什么区别呢？ hexo new page &quot;my-second-blog&quot;生成如下： 最终部署时生成：hexo\\public\\my-second-blog\\index.html，但是它不会作为文章出现在博文目录。 写博客工具那么用什么工具写博客呢？这个我还没去找，以前自己使用editor.md简单弄了个，大家有好用的hexo写博客工具可以推荐个。 如何让博文列表不显示全部内容默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？ 答案是在合适的位置加上&lt;!--more--&gt;即可，例如： # 前言 使用github pages服务搭建博客的好处有： 1. 全是静态文件，访问速度快； 2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； &lt;!--more--&gt; 4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 5. 博客内容可以轻松打包、转移、发布到其它平台； 6. 等等；最终效果：","link":"/2019/08/07/hexo写博客发布到github教程/"},{"title":"Android Handler消息机制","text":"简介 消息发送 消息存储与消息循环 简介在Android开发中，经常会遇到需要在不同线程之间切换的需要，比如网络请求（Android为了防止出现ANR异常，所以规定在Main Thread中不能进行网络请求，且最好不要进行耗时操作），子线程通信等等。此外，Android在设计之初，为了安全和用户体验考虑，规定了只允许在Main Thread里面进行UI更新，而不能在子线程里面进行，否则会抛出异常。这个时候，就需要用到Android的消息传递机制 — Handler。在Android中，Handler消息传递机制主要依赖于Handler，Message，MessageQueue，Looper。其中： Handler负责消息的发送与接收处理。 Message负责消息的封装，他本身可以看做消息的载体。 MessageQueue：是一个消息队列，所有需要发送的消息用类似于链表的形式进行存储，并且依据于消息消费的时间为标志确定存储位置。 Looper：进行消息循环与消息分发。 简单使用如下： 12345678910111213Handler handler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); LogUtils.d(\"腾讯云Imi handler out --\"); if (TLSService.getInstance() != null &amp;&amp; TLSService.getInstance().getLastUserIdentifier() != null) { isIMNotinit = false; presenter.getUnreadNum(getContext()); presenter.getConversation(getContext(), true); LogUtils.d(\"腾讯云Imi handler\"); } } }; 在使用Handler时，创建一个Handler并重写其handleMessage方法，参数Message中包含了传递的信息，信息来源等等，可以根据msg.what判断消息来源并做相应处理。但不建议这样直接创建，如果这样在Activity中创建的话，当activity被finish之后，可能有消息还在继续发送，而此时的message中保留有activity中handler的引用，而这个handler里面有这个被finish的activity的隐式引用，导致此activity无法被销毁，这样就会有内存泄漏的风险。解决办法一般是不让Handler内部类不持有外部activity的强引用，如下所示： 123456789101112131415161718192021private static class MyHandler extends Handler { private WeakReference&lt;Context&gt; mContextReference; public MyHandler(Context c) { mContextReference = new WeakReference&lt;Context&gt;(c); } @Override public void handleMessage(Message msg) { final Context c = mContextReference.get(); if (c != null) { if (CommonUtils.notEmpty(msg.obj.toString())) { Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); Uri uri = Uri.fromFile(new File(msg.obj.toString())); intent.setData(uri); c.sendBroadcast(intent); // 发送广播通知相册 } Toast.makeText(c, \"图片下载完成\", Toast.LENGTH_SHORT).show(); } } } 把Handler设置为静态类，静态类不持有外部类的对象，所以activity销毁的时候不会受到Handler的限制，并且在Handler里面用到activity是持有的弱引用，不影响外部activity的销毁。 消息发送上面是Handler接收到消息之后的最终处理，接下来看看消息发送的情况。Handler有多个方法用来应对不同情景的数据发送，以下为几个例子： 1.sendEmptyMessageDelayed(int what, long delayMillis)，带有消息来源的延时消息发送。 12345public final boolean sendEmptyMessageDelayed(int what, long delayMillis) { Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);} 2.sendEmptyMessage(int what) 只包含来源身份信息的空消息发送 1234public final boolean sendEmptyMessage(int what){ return sendEmptyMessageDelayed(what, 0);} 3.sendEmptyMessageDelayed(int what, long delayMillis) 延时空消息发送 12345public final boolean sendEmptyMessageDelayed(int what, long delayMillis) { Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);} 4.sendMessageAtFrontOfQueue(Message msg)把消息放入队列头部，其实实现是把延时发送消息设置为0。 12345678910public final boolean sendMessageAtFrontOfQueue(Message msg) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; } return enqueueMessage(queue, msg, 0); } 等等…… 可以看到，所有方法都调用到了sendMessageAtTime方法，只是参数不同而已。 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis);} 方法参数Message信息与消息消费时间。判断了是否存在MessageQueue，为空则会报错，存在则把消息根据时间放入queue中，再看看这个MessageQueue是什么时候初始化的。 12345678910111213141516171819public Handler(Callback callback, boolean async) { if (FIND_POTENTIAL_LEAKS) { final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); } } mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } 通过跟踪我们可以发现，用来存储消息的MessageQueue是在Handler初始化的时候初始化的，mQueue = mLooper.mQueue; 且这个mLooper也是这个时候通过Looper.myLooper();初始化的，我们现在去Looper里面看看这个初始化过程： 123public static @Nullable Looper myLooper() { return sThreadLocal.get();} 可以发现，是从一个ThreadLocal里面拿到的Looper对象，继续查看是在哪里进行Looper对象的设置的。 1234567891011private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed));}private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 通过跟踪观察可以发现，Looper是在通过Looper.prepare（）方法把Looper对象放入ThreadLocal对象里面的，并且在此时创建了MessageQueue对象。所以当我们在子线程使用Handler的时候，在创建Handler前必须要先调用Looper.prepare()方法的原因了，因为在创建Handler的时候会进行Looper的初始化。如果没有先调用Looper.prepare()的话，sThreadLocal.get()的值就为空，就会抛出RuntimeException。此外有个特例就是，如果我们在Main Thread里面使用Handler的话则不需要使用Looper.prepare()就可以直接创建Handler使用了，其实这是因为在Android程序创建的时候已经调用过这个方法了。Android程序刚开始的入口是ActivityThread的main方法，在里面可以看到相关的设定： 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); } 我们可以看到，在ActivityThread的main方法里面，调用了Looper.prepareMainLooper();方法创建Looper对象，并且最后还调用了Looper.loop(); 方法进行消息循环，这也是在Main Thread里面调用为何不需要提前用Looper.prepare()就可以直接使用的原因了。我们再看看Looper.prepareMainLooper()是怎么创建Looper对象的： 123456789public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(\"The main Looper has already been prepared.\"); } sMainLooper = myLooper(); }} 在prepareMainLooper方法里面调用了prepare方法，并且Main Thread里面和其他子线程里面都保证了只能创建一次Looper对象，即一个线程只能有一个Looper对象，否则会抛出IllegalStateException的异常。 到此对Handler，Looper的创建做一个总结： 在子线程创建使用Handler的时候必须先调用Looper.prepare（）方法创建Looper，Looper里面创建的对象由一个ThreadLocal对象进行存储，主线程创建使用Handler的时候不需要提前调用Looper.prepare()方法，因为在程序开始的时候在ActivityThread的main方法里面已经调用过Looper.prepareMainThread（）方法了。每个线程里面只能调用Looper.prepare（）方法一次，只能创建一个Looper对象，否则会抛出异常。 Handler创建的时候，会调用Looper的方法去实例化Looper和MessageQueue对象。 消息存储与消息循环几乎所有的发送消息的方法最后都调用了sendMessageAtTime方法，在这个发放中判断了是否存在MessageQueue对象之后调用了enqueueMessage方法，在这个方法中，把msg.targt设置为此Handler对象，注意，这里是用于之后在MessageQueue里面消费消息时找到对应的处理此消息的Handler，然后调用MessageQueue的enqueueMessage（）方法，此方法主要是用于把消息放入MessageQueue里面，即入队操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(\"Message must have a target.\"); } if (msg.isInUse()) { throw new IllegalStateException(msg + \" This message is already in use.\"); } synchronized (this) { if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true; } Message消息通过MessageQueue的enqueueMessage方法进行入队操作，在此方法中先判断msg.target是否存在，当前消息是否在使用中，是否收到退出信息等的检测，全部正常才进行入队，从上面代码我们可以看到，MessageQueue是通过类似于链表的形式存储Message消息的，且是通过消费时间进行排序的，通过前面我们可以知道，入队用于排序的时间是Message的消费时间，即System.currentTime()+delayMillis;循环遍历消息队列，找到msg.when应该插入的地方，插入链表，完成消息的入队操作。这里还需要注意的是nativeWake(mPtr);方法，这个方法是用通过JNI实现的，即在底层通过C实现的，然后通过JNI调用，在底层中维持了一个mWakeEventFd文件，这个文件是专门用于进程和线程之间通信的，并且通过epoll监控。这里在入队完成之后会调用此方法，通过此方法会向MwakeEventFD文件写入一个uint64_t，这个是用于唤醒消息循环线程的，在后面消息取出的时候进行详细说明。 通过上面的方法就完成了消息发送过程，接下来则是消息循环过程，当消息的消费时间到了之后取出相应的消息进行消费。通过上面的时候我们知道在线程中使用完Handler之后需要调用Looper.loop()完成整个过程，在主线程不需要我们操作是因为ActivityThread里面已经调用过了，在loop（）里面做的就是消息的阻塞等待。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) { logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); } final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) { Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); } final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); final long end; try { msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } if (slowDispatchThresholdMs &gt; 0) { final long time = end - start; if (time &gt; slowDispatchThresholdMs) { Slog.w(TAG, \"Dispatch took \" + time + \"ms on \" + Thread.currentThread().getName() + \", h=\" + msg.target + \" cb=\" + msg.callback + \" msg=\" + msg.what); } } if (logging != null) { logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); } msg.recycleUnchecked(); } } 从代码中我们可以看出，这是个无限循环方法等待获取可以处理的消息，在循环里面，通过do-while找到一个不为空且是asynchronous的消息，找到之后检测这个消息是否到了执行时间，如果不到的话，通过Math.min(msg.when - now, Integer.MAX_VALUE);设置等待时间，如果这个消息找到了，且到了执行时间了，那么就取出此消息，并把链表中此消息删除，把这个消息通过msg.markInUse();标志为使用中，把这个找到的消息返回给Looper的loop方法，进行消息分发。如果到了链表尾部还是没有符合的消息，则进入阻塞等待过程。 另外在此方法中还得注意nativePollOnce(ptr, nextPollTimeoutMillis);这个方法也是JNI调用C++实现的。之前说到在通过Handler发送消息的时候，会向mWakeEventFd文件写一个uint_64，而nativePollOnce方法则阻塞监听mWakeEventFd文件以及唤醒消息循环线程的。当有消息发送的时候就会写入一个uint_64，而nativePollOnce里面则是一直监听这个文件，当有写入操作发生时，就会唤醒epoll_wait即消息循环线程，线程就会去取出队列里面的消息去执行操作，当队列里面没有消息的时候，又会继续等待，当下次有信息写入的时候则再次唤醒线程去取出队列消息。这样就完成一次消息循环。 继续看上面的取出消息之后的处理，上面说到取出消息之后loop（）方法是调用了msg.target.dispatchMessage方法进行消息处理，而msg.target是之前设置的目标Handler，现在去Handler里面看看dispatchMessage的处理： 123456789101112 public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 这里就是如何处理信息了，如果为Message设置了callback的话则直接message.callback.run()；处理消息，如果有设置Handler的callback，也进行分发；如果都没有的话，那就直接调用handleMessage(msg);还记得我们最开是的时候写的简单使用Handler的例子么，里面重写了一个方法，就是handleMessage(msg);所以到这里就清楚了，前面发出的消息就是在这里进行处理的。另外还有很多经常用的方法都是通过包装的Handler来进行的，比如： Activity.runOnUiThread(Runnable action)1234567public final void runOnUiThread(Runnable action) { if (Thread.currentThread() != mUiThread) { mHandler.post(action); } else { action.run(); }} 这个是Activity的方法，用于在切换到主线程运行，可以看到内部实现是判断当前线程是否是主线程，如果是的话直接运行，不是的话用mHandler.post发送出去，而mHandler是申明在主线程的Handler，经过发送之后再主线程的Handler里面完成调用。 View.post() 1234567891011public boolean post(Runnable action) { final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) { return attachInfo.mHandler.post(action); } // Postpone the runnable until we know on which thread it needs to run. // Assume that the runnable will be successfully placed after attach. getRunQueue().post(action); return true;} View.post()用于异步更新view，也是找到主线程Handler，然后通过Handler发送消息，在主线程更新Handler。另外还有很多经典方法都是用Handler更新数据的，最典型的是Android官方提供的异步工具AsyncTask，用它可以进行异步请求或者异步下载数据，下载图片等等，AsyncTask就是用Handler实现的多线程异步工具，开启子线程进行数据请求，然后通过Handler发送数据消息，最好在主线程里面处理收到的消息，完成异步请求。 ###总结 在使用Handler的时候，主线程不需要调用Looper.prepare()创建Looper，因为在程序开始的时候在ActivityTask里面的main方法里面调用了Looper.prepareMainLooper()创建了Looper对象，子线程中需要先调用Looper.prepare()创建Looper对象。每个线程只能有一个Looper对象。在创建Looper的时候会初始化MessageQueue对象，因为在创建Handler的时候需要是用到Looper对象以及MessageQueue对象，并且在Looper中保存示例是放在ThreadLocal里面的。 初始完成之后用Handler发送信息，包括信息数据Message以及delayMillis，之后调用MessageQueue的enqueueMessage（）把消息按类似于链表结构并按照时间顺序排列，此时还会调用nativeWake(mPtr)方法向底层的mWakeEventFd文件写入uint64_t，唤醒消息循环线程。子线程发送完数据之后调用Looper.loop(),死循环等待到时间处理的消息出队，Looper取到消息之后，就进行消息分发，根据设置的callback进行处理消息，如果没有设置则调用Handler的handleMessage处理消息。MessageQueue的next方法负责进行消息出队操作，无限循环检查是否有到时间的消息，如果有则把他出队，如果没有则循环阻塞。 出队消息然后交给Looper的loop方法进行消息分发。在消息出队的时候会调用nativePollOnce(ptr, nextPollTimeoutMillis)方法，这个方法是用来通过epoll监听mWakeEventFd文件的，当监听到有uint64写入文件的时候唤醒消息循环线程取出消息并处理，没有消息的时候沉睡等待下次uint64的写入。这样就完成了一次消息的收发。","link":"/2019/08/08/Android Handle机制/"},{"title":"Tools wiki","text":"在线开发工具 insert pic with local pic with online pic with base64 pic 在线开发工具好用的在线工具：加密,格式化，转码，换算 insertpiclocalpic onlinepic base64pic12//![avatar](base64str1）//[base64str1]:data:image/png;base64,iVBORw0......","link":"/2019/08/08/tools-wiki/"},{"title":"Android All Versions new features","text":"Android 4.0 Android 5.0 Android 6.0 Android 7.0 Android 8.0 Android 9.0 Android 10.0 Android4.0 Space 留白 PopupMenu GlidLayout 网格布局 Android5.0 MaterialDesign设计风格 Material Theme Meterial Dialog CardView RecyclerView SwipeRefreshLayout Toolbar RippleDrawable 视图的水波纹效果 android L 增加了一些 Activity 的转场动画 —— 爆炸、滑动、淡入淡出 tint 前后背景着色 Palette 从图像中提取突出的颜色，这样可以把色值赋给 ActionBar、Toolbar、或者其他，可以让界面整个色调统一。 支持64位ART虚拟机 Heads-Up 风格通知。全新的通知中心设计（在锁屏界面也可以直接查看通知消息了，用户还可以直接在锁屏的情况下就行回复或进入应用。） setTaskDescription 最近使用。全新的“最近应用程序”。除了界面风格设计的改变之外，新的 近应用界面还借鉴了 Chrome 浏览器的理念，采用单独的标签展示方式。更重要的是，谷歌已经向开发者开放了 API，所以第三方开发人员可以利用这个改进为特定的应用增加全新的功能。 Project Volta 电池续航改进计划。增加了 Battery Saver 模式，在低电量的时候系统会自动降低屏幕亮度、限制自动更换背景等功能。 MediaProjection 截屏 JobScheduler 通过为系统定义要在以后的某个时间或在指定的条件下（例如，当设备在充电时）异步运行的作业来优化电池寿命 setClipToOutline 裁剪 支持多种设备（手机、平板电脑、笔记本电脑、智能电视、汽车、智能手表甚至是各种家用电子产品） 新的 API 支持，蓝牙 4.1、USB Audio、多人分享等其它特性 Camera2 PdfRenderer 使用位图来呈现 PDF 文件 android.app.usage API 获取应用使用情况统计信息的 API Android6.0 指纹识别 动态权限申请 FloatingActionButton Snackbar TabLayout NavigationView CoordinatorLayout AppBarLayout CollapsingToolbarLayout App Linking TextInputLayout 大量漂亮流畅的动画 支持快速充电的切换 支持文件夹拖拽应用 相机新增专业模式 全新的电源键菜单 一般来说，安卓的电源键菜单都是关机/重启/飞行，安卓6.0变成了关机/重启/紧急，关机和重启就不用赘述了，这个紧急模式是为了手机快没电的时候设计的，相当于飞行模式的高级版，可以关闭一切耗电应用，尽最大可能节省电量。 可自定义锁界面样式 支持电话、信息、相机等快捷方式在锁屏界面的定制，用户可以根据自己的喜好调整这些图标的位置，或者开启或关闭这些快捷方式。 全新的快速设置风格 不但是锁屏界面可以定制，安卓6.0还采用了全新的快速面板的色彩方案，用户可以通过更换主题换颜色。 原生的应用权限管理 无需第三方应用和Root权限，原生的安卓6.0就支持应用权限管理，用户可以在安装应用时选择关闭一些应用权限，这一功能非常方便，再也不用担心流量偷跑和扣费了。 Now on Tap功能 “Now on Tap ”功能，是指将Google Now(一种语音助手)作为底层植入到安卓6.0系统中，用户只要只要双击home键启动Google Now，“这意味着用户随时都能启动搜索功能，目前暂时不知道这个功能进入国内会不会阉割掉。 支持RAW格式照片 RAW格式的支持是众多拍照爱好者梦寐以求的， 然而绝大多数的安卓手机都没有或者剔除了这项功能。由于照片保存为jpg格式时或多或少都会损失一些画质，所以支持RAW格式是非常明智的。 Android7.0 画中画 分屏多任务 增强的Java8语言模式 通知栏快速回复 夜间模式 OpenJDK替换Java API Android 7.0中采用了一项具有实时代码剖析功能的ARI JIT编译器，它能够在安卓应用程序在运行时不断提高自身的性能 Android8.0 通知变更 引入了通知渠道用来让用户统一管理通知。 Android O 还引入了通知角标，当一个应用的通知没有 dismiss 的时候，会在应用的图标上面显示一个角标，长摁这个应用的图标，也会显示通知的详情信息。 同时还引入了一个通知睡眠的功能，用户可以休眠一个通知，让它在指定的时候再出现，被休眠的时候仍然可以修改这个通知的设置，但是不会让这个通知立马出现。另外还可以设置一个通知的超时时间，用来让某个通知在一段时间之后被自动 cancel。 其他的比如可以获取通知的清除方式，修改通知的背景颜色，修改通知的样式 画中画模式 在 Android O 之前，画中画模式已经可用于 Android TV，而 Android O 则让这一个功能可以支持到其他的 Android 设备 自适应图标 自动填充框架 xml 字体和可下载字体 Pinned Shortcut 这个功能在 7.1.1 之后就已经有了，长摁桌面图标就会显示一个 App shortcuts 菜单栏，然后长摁菜单栏上的一项，就能把它拖下来成为单独的一个应用图标，被拖下来的单独的应用图标就是Pinned shortcuts，虽然这个功能在 7.1.1 引入的，但是在 O 版本我们可以通过提供的 API 按照一定的步骤去使用代码添加 TextView 字体自动适配 媒体增强 其他特性 *可以设置 Activity 支持广色域；*可以设置最大的屏幕宽高比；*多屏幕支持，支持设备外接一个显示器；*最新版本 emoji 支持，使用 EmojiCompat 类可以让应用在老版本的应用上显示新的 emoji；*支持点击位置的捕捉；*支持设置应用类别，这些类别用于将应用呈现给用户的用途或功能相同的应用归类在一起，例如按流量消耗、电池消耗和存储消耗将应用归类。 Smart Text Selection，这个功能有人可能在今年老罗的锤子手机发布会上看到过，思想是很类似的，复制一段数字，就会出现直接拨打电话的选项，复制一段地址就会弹出进入地图的选项，地图 APP 可以一下这个地方能否成为一个很方便入口。 行为变更 后台执行限制 安全性 网络连接和 HTTP(S) 连接 权限：在 Android O 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。对于针对 Android O 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。 媒体变更 Native libraries 其他 12345678 1. ContentProvider 支持分页，即获取内容的选中区域的子集；2. ContentProvider 和 ContentResolver 增加 refresh 方法，用来让客户端更容易的知道数据是不是最新； 3. JobScheduler 更新，让应用更容易遵从后台执行限制；4. 集合的处理的变化，AbstractCollection.removeAll() 和 AbstractCollection.retainAll() 始终引发 NullPointerException；5. 语言区域和国际化变化(https://developer.android.com/preview/behavior-changes.html#lai)；6. 联系人提供程序使用情况统计方法的变更(https://developer.android.com/preview/behavior-changes.html#cpu)；7. 蓝牙 ScanRecord.getBytes() 方法检索的数据长度变更(https://developer.android.com/preview/behavior-changes.html#bt)； 8. 输入和导航(https://developer.android.com/preview/behavior-changes.html#ian)； API 变更 WebView 新 API findViewById：findViewById 函数现在返回的是 ，所以以后 findViewById 就不需要强转了。 统一的 margins 和 padding：layout_marginVertical，layout_marginHorizontal，paddingVertical，paddingHorizontal AnimationSet：支持了动画的 seek 和动画倒转播放 提醒窗口 Android9.0 全面屏的全面支持** ** 加入了对刘海屏的支持（谷歌称之为凹口屏幕（display with a cutout）。借助最新的提供的DisplayCutout类，开发者可以找到非功能区域的位置和形状，而非功能区域是不应显示功能的；使用getDisplayCutout（）就可以获取这个区域的详细信息，未来刘海屏手机很有可能成为主流趋势，在前摄像头没有比较好的隐藏方案出现之前，这可能是提高屏占比的好方法。（屏占比=屏幕面积/整机面积）2.New gesture navigation(新的手势导航栏) 引入了一种新的基于手势的系统界面，界面下方会有一个小的横线式主屏键，有点类似于iPhone X的手势操作，很多操作逻辑与iPhone X相似、但更人性化，相对来说，iPhone X的“横线”只是个摆设式的提醒UI，而Android 9.0 Pie则赋予它真正的操作能力。在椭圆指示器上滑动可以作为滚动条，但是在新的导航条上仍然有一个返回键。向右滑动可以访问最近的应用，或者向上滑动可以访问你的应用抽屉和应用建议。它在Pixel手机上非常流畅。切换到以前的应用程序，在浏览窗口后，在底部添加一个滑块。3.自适应功能** Adaptive Battery（电量自适应）：更智能的方式来适应电池和屏幕，从而整体改善续航能力。谷歌加入了Adaptive Battery功能，不过这个模式需要单独开启，在该模式下，程序不需要唤醒可以极大的降低资源占用，更关注用户最常用的服务和应用程序，也算是AI技术的应用之一。这样就可以最大限度的降低后台占用，从而提升电池续航能力。这是Android团队与Google DeepMiind团队合作开发的成果，不仅可以预测用户接下来几个小时内将使用的应用程序，而且还包括在当天用户何时会使用哪些应用程序。智能的一种应用。 Adaptive brightness（亮度自适应）:亮度方面也进行了人工智能升级，通常情况下用户需要手动调节，或者通过光线传感器进行自动调整，但往往不够精准，有时候过亮或者过暗一点，但用户也不会太过于在意。新的Adaptive Brightness技术同样通过学习用户使用习惯和偏好来解决这个问题，比如你经常在比较明亮的环境下使用，那么手机会自动的调整到更适合的情况，除了充分考虑到用户周围环境之外，也允许学习用户的习惯，了解你当前的亮度需求。4.网络还有神经网络** 在Android P上，任务可以声明它们估算的数据大小，信号预读取并且指定详细的网络需求–任务载体则可以报告网络是否拥挤或是否不计量。JobScheduler便可按照网络状态管理任务。另一方面，神经网络API在Android 8.1引入，目的是加速Android设备上的机器学习。Android P扩展并改进了这些API, 为9个操作增加了支持，分别是Pad, BatchToSpaceND, SpaceToBatchND, Transpose, Strided Slice, Mean, Div, Sub和Squeeze。在Android P之后，设备将会对网络有更精细的调整：根据任务需求的数据大小和当前的网络环境。在收费网络里延迟一些网络要求，而在不计费的网络里可以通过消息预获取来得到更好的用户体验。神经网络API的更多操作则是让设备变得更智能、更聪明。智能的一种体现，节省流量和网络速度优化体验的一种好的改进。 WindDown** WindDown是一项新功能，它可以在你选择的就寝时间自动打开夜灯和DND模式，让你更容易入睡。新的DND管理模式，它可以停止所有的调用或通知声音，甚至可以在你获得新的声音时弹出预览。“下风”功能实现了这三种功能:在晚上打开夜灯，在DND模式下快速运行，甚至在睡眠时间接近时以灰度显示。所有这些都有一个手势——把你的手机翻过来，它就会自动进入数字健康模式。 App Actions：应用程序操作**这类似于你可以通过长时间按下图标来调用应用程序的快捷方式，但考虑到它是谷歌启动程序，它可以为你的手机提供一些建议，因此完全不同。这个特性推荐使用AI进行操作。AI会尝试找出你接下来要做什么，以及你接下来需要什么，当你启动app抽屉时，它会告诉你。根据你的当前地理位置、一天中的某个时间段，甚至是你连接耳机的时候，向你推荐一些东西。还有位于应用程序抽屉中的快捷键可以预测你将要做什么，这样你就可以更快地完成你在手机上要做的事情。例如，如果你通常打开应用程序面板，然后打开手机应用程序，然后给你的好朋友打电话。 应用定时器**设置应用程序的时间限制，当你在指定的时间段内使用它们之后，Android会自动将应用程序的图标变灰——暗示你应该把时间花在使用应用程序以外的事情上。可以自由设置程序的使用时限。 切片App slices**slice为你提供了应用的一部分，Android系统认为这是你在寻找某个应用时需要的功能。例如，如果你在搜索中输入“Hawaii”，一个应用程序切片可能会建议你在谷歌photos应用中查看你最近的夏威夷度假照片。比如你要打车，Slices可以做到这一点，搜索“Lyft”，你就会看到一个能给你提供价格和时间，你可以用来完成预约服务。 辅助功能菜单**在Settings&gt;Accessibility &gt; Accessibility Menu中你可以激活新的辅助功能菜单，该菜单会启用一个图标，您可以点按该图标以执行快速设置，设置最近的应用和音量等操作。 Android Dashboard** 它告诉你在手机上花了多少时间，以提醒用户尽量少用这个APP，这与iOS系统的“屏幕时间”功能类似，用户能够更好地去管理自己在手机上的使时间。 Manual rotation（手动旋转）** 那些很烦的自动旋转现在可能成为过去。现在旋转屏幕也可以是手动的了，在导航栏上有一个指示器可供点击。 Security and privacy features（安全和隐私特性）** Android Pie引入了大量新的安全和隐私特性，以帮助您保持数据的安全性。更新中引入的最有用的特性之一是，当你的麦克风、摄像头或传感器空闲时，应用程序将不再能够访问它们。所有应用都使用HTTPS，这是对Android安全用户的肯定。AndroidPie上的所有应用程序默认都使用HTTPS。Android关心您的隐私。 Do Not Disturb（免打扰）**它现在将屏幕变成了灰度，同时也明显地禁用了通知，除非有重要联系人来呼叫你。 Better notification management(更好的通知管理)**可以关闭一系列应用程序的通知，系统甚至可能会要求你在取消通知后停止接收特定类型的通知。让你进入AI时代。您现在可以在消息应用程序中查看图像，并使用smartreply使用notificationshade来回复邮件。此外，Android还会通过分析收到的消息来快速做出反应，或者增加一个action以对消息或从通知直接进入文字的行为作为反映。如：直接在通知栏跟好友聊天；直接在通知栏直接看到好友发送的图片。 GPS定位之外的WiFi定位** 通过WiFi往返时延室内定位(RTT表示往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延)，简单理解就是室内无线电波(WIFI)、磁场、声音信号或移动设备收集的其他感觉信息来定位建筑物内物体或人的技术。 支持设备使用插槽连接来显示** 手机可以连接电脑显示屏，来感受大屏显示的魅力。 多摄像头支持，增加了连接USB摄像头的功能**在Android Pie的设备上，用户可以同时从两个或多个物理摄像头访问数据流。在具有双前置或双后置摄像头的设备上，可实现使用单个摄像头无法实现的创新功能，例如无缝变焦，散景和立体视觉。API还允许调用或融合的摄像机媒体流，以自动在两个或更多摄像机之间切换。相机中的其他改进包括 有助于减少初始捕获期间延迟的其他会话参数，以及允许相机客户端处理各种用例而无需停止和启动相机流的表面共享。我们还添加了基于显示的闪存支持和访问OIS时间戳的 API，以 实现应用级图像稳定和特效。在Android Pie中，多摄像头API 支持具有FULL或 LIMITED功能的设备的单色摄像头 。单色输出通YUV_420_888 Y为灰度,U（Cb）为128，V（Cr）为128 的格式实现 。 黑暗模式** 你可以在Settings&gt;System &gt; Display &gt; Advanced &gt; Devicetheme中选中“Dark“项来打开该功能，来让Android设备上变暗。 新截图快捷方式**告别默认的Power+ Volume Down按钮组合，现在通过点击Power菜单中的图标可以随时获取屏幕截图。 仪表板** Android的仪表板显示显示你花了多少时间使用手机，并通过以下方式将使用数据细分为更全面的部分:一个饼图，表示每天花在应用程序上的时间解锁设备的次数您的通知总数您每天在设备上花费的小时数。 媒体面板** 由于音量控制专用于振铃器音量，Android的媒体设置现在将在屏幕右侧垂直对齐的滑块中显示音量控制，并且同一媒体面板为。连接到您的Android手机的所有设备显示不同的音量控制设置。 157个新的Emojis表情** 157是一个很大的数字，包括美洲驼、冷脸、热脸、芒果果、滑板等。谷歌严格遵守其Unicode标准，去掉了中性字符。 Wi-FiMAC随机化功能** 每次连接到新的Wi-Fi网络时，都会为设备随机分配新的MAC地址。这是第9版Android隐私和安全功能的众多改进之一。 支持指纹确认的安全事务** 在Android Pie中，系统代表您的应用提供生物识别身份验证对话框。此功能为对话框创建标准化的外观，感觉和位置，使用户更有信心他们对可信赖的生物识别凭据检查器进行身份验证。如果您的应用程序用于FingerprintManager向用户显示指纹身份验证对话框，请切换为使用BiometricPrompt。BiometricPrompt依赖于系统来显示身份验证对话框。它还会更改其行为以适应用户选择的生物识别身份验证的类型。 改进了JobScheduler以便更好地处理与网络相关的工作。** 从Android Pie开始，JobScheduler可以使用运营商提供的网络状态信号来改善网络相关作业的处理。 JobScheduler可以声明其估计的数据大小，信号预取，并指定详细的网络要求。JobScheduler然后根据网络状态管理工作。例如，当网络发出拥塞信号时， JobScheduler可能会推迟大型网络请求。在未计量的网络上，JobScheduler可以运行预取作业以改善用户体验，例如通过预取标题。 添加作业时，请务必使用setEstimatedNetworkBytes()，setPrefetch()并setRequiredNetwork()在适当时帮助 JobScheduler正确处理工作。当您的作业执行时，请务必使用Network返回的对象JobParameters.getNetwork()。否则，我们可以将隐式使用设备的默认网络，该网络可能无法满足您的要求，从而导致意外的数据使用。 bitmaps and drawables使用了新的解码器解码** Android Pie引入了ImageDecoder类，效率更高效。它提供了一种用于解码图像的现代化方法。使用此类而不是BitmapFactory和BitmapFactory.Options API。ImageDecoder允许new一个Drawable或一个 Bitmap字节缓冲区，文件或URI。要解码图像，请先createSource() 使用编码图像的来源进行调用 。然后，调用decodeDrawable() 或decodeBitmap() 通过传递ImageDecoder.Source 对象来创建一个Drawable]或一个Bitmap。要更改默认设置，请传递OnHeaderDecodedListener给 decodeDrawable()或decodeBitmap()。一旦知道，就ImageDecoder调用onHeaderDecoded()图像的默认宽度和高度。如果编码图像是动画GIF或WebP，则decodeDrawable()返回该类Drawable的实例 AnimatedImageDrawable。我们可以使用不同的方法来设置图像属性：要将解码图像缩放到精确大小，请将目标尺寸传递到 setTargetSize()。您还可以使用样本大小缩放图像。将样本大小直接传递给setTargetSampleSize()。要在缩放图像范围内裁剪图像，请调用 setCrop()。要创建可变位图，请true进入setMutableRequired()。ImageDecoder还可以为图像添加自定义和复杂的效果，如圆角或圆形蒙版。setPostProcessor()与PostProcessor 类的实例一起使用以达到想要的任何绘图效果。 新的“AnimatedImageDrawable”类：用于在UI中支持本地动画**Android Pie引入了AnimatedImageDrawable用于绘制和显示GIF和WebP动画图像的类。AnimatedImageDrawable类似于 AnimatedVectorDrawable渲染线程驱动动画的方式AnimatedImageDrawable。渲染线程还使用工作线程进行解码，因此解码不会干扰渲染线程上的其他操作。此实现允许您的应用显示动画图像，而无需管理其更新或干扰应用的UI线程上的其他事件。一个AnimatedImageDrawable可以利用的实例进行解码ImageDecoder。 支持HDR VP9视频和HEIF图像压缩**Android Pie增加了对高动态范围（HDR）VP9配置文件2的内置支持，因此我们现在可以通 过YouTube，Play电影和支持HDR的设备上的其他来源播放用户提供支持HDR的电影。Android Pie增加了对平台的HEIF（heic）图像编码的支持。HEIF静态图像样本在MediaMuxer和MediaExtractor类中得到支持HEIF改进了压缩以节省存储和网络数据。借助Android 9设备上的平台支持，您可以轻松地从后端服务器发送和使用HEIF图像。确保您的应用与此数据格式兼容以进行共享和显示后，请在应用中尝试将HEIF作为图像存储格式。您可以使用ImageDecoder或BitmapFactory进行jpeg-to-heic转换以从jpeg获取位图，并且可以使用HeifWriter从YUV字节缓冲区，Surface或Bitmap写入HEIF静止图像。 Autofill框架的进一步改进**(Autofill Framework最低支持SDK API 26(Android O)+),Demo地址：https://github.com/googlesamples/android-AutofillFramework，Android 9引入了多项改进，自动填充服务可以实现这些改进，以在填写表单时进一步增强用户体验。 客户端加密备份** Android Pie增加了对使用客户端密钥加密Android备份的支持。满足以下条件时，将自动启用此支持： 用户已使用Android Pie或更高版本启用了备份。 用户已为其设备设置了屏幕锁定，需要PIN，图案或密码才能解锁。启用此隐私措施后，需要设备的PIN，模式或密码才能从用户设备的备份中恢复数据。 Material Design迎来2.0时代** Android 9.0加入了大量的圆角设计，UI方面的优化，感觉有些鸡肋，在现在各种模仿的设计趋势和各种定制化UI下，许多功能只是看看而已，用不到多少 Android10.0Android Q 隐私更改相关介绍 存储范围变更Android Q 改变了应用程序访问设备外部存储上文件的方式。通过使用更细粒度的媒体特定权限替换以前的 READ_EXTERNAL_STORAGE 和 WRITE_EXTERNAL_STORAGE权限。 外存中私有目录权限变更Android Q 为每个应用程序提供了一个独立的在外部存储设备的存储沙箱，没有其他应用可以直接访问您应用的沙盒文件。由于文件是私有的，因此访问这些文件不再需要任何权限。并且 Android Q 推荐了获取外部存储私有文件的最佳位置：即Context.getExternalFilesDir（）返回的位置，因为此位置在所有Android版本中表现一致。使用此方法时，请传入与要创建或打开的文件类型对应的媒体环境。例如，要访问或保存app-private图像，请调用Context.getExternalFilesDir（Environment.DIRECTORY_PICTURES）。 公共媒体集合特性定义公共媒体集合：Photos &amp; Videos、Music、 Downloads。APP 无需请求任何权限即可在这些共享集合中创建和修改自己的文件。如果你的APP想创建和修改其他应用已创建的文件，则必须首先请求相应的权限：访问Photos &amp; Videos目录的其他应用程序文件 需要请求 READ_MEDIA_IMAGES 或 READ_MEDIA_VIDEO 权限，具体取决于您的应用程序需要访问的文件类型。访问 Music 共享集合中的其他应用程序文件需要 READ_MEDIA_AUDIO 权限。没有访问Downloads共享集合的权限，您的应用可以访问此集合中自己的文件。但是，要访问此集合中的其他应用程序文件，您必须允许用户使用系统的文件选择器应用程序选择文件。 访问共享集合访问共享集合通过 MediaStore API ，如 MediaStore.Images、MediaStore.Video、MediaStore.Audio、MediaStore.Downloads。需要注意的是：对于 Android Q 上新安装的应用，对 getExternalStoragePublicDirectory（）的调用仅提供对应用已存储在其隔离存储沙箱中的文件的访问权限。要保持对其他应用程序文件的访问权限，请更新应用程序的逻辑以使用MediaStore。 新增 ACCESS_MEDIA_LOCATION 权限一些照片在其数据中会包含位置信息，允许用户查看拍摄照片的位置。由于此位置信息是敏感的，因此我们想获取位置信息需要以下几步：1.将新的 ACCESS_MEDIA_LOCATION 权限添加到AndroidManifest。 2.获取位置信息photoUri = MediaStore.setRequireOriginal(photoUri);InputStream stream = getContentResolver().openInputStream(photoUri);//从流中读取位置信息 存储新特性兼容target API 级别等于 Android Q 的应用，或者在运行Android Q 的设备上新安装的应用默认都会采取新的权限策略如果你的APP同时满足以下两个条件，则会兼容以前的权限策略：targetSdkVersion &lt;= Android 9你的应用安装在从 Android 9 升级到 Android Q 的设备上识别特定的外部存储设备Android Q 为每个外部存储设备提供唯一的卷名。 //获取卷名方式Set volumeNames = MediaStore.getAllVolumeNames(context); Activity后台活动限制Android Q 对应用未经通知用户就启动进行了极大地限制，在Android Q上运行的应用只有在满足以下一个或多个条件时才能启动活动：该APP具有可见窗口，例如有前台Activity位于前台的另一个 APP 发送属于该应用程序的 PendingIntent。系统发送属于该 APP 的PendingIntent，例如点击通知。系统向应用程序发送广播，例如SECRET_CODE_ACTION。只有应用程序预期启动UI的特定广播才免除。 活动限制的兼容性此行为更改适用于在 Android Q 上运行的所有应用，甚至是针对Android 9（API级别28）或更低级别的应用。但是，只要您的应用以用户互动的直接结果开始活动，您的应用很可能不会受到此更改的影响。实际上，大多数应用程序都不受此更改的影响。此外，Android Q 建议我们 后台应用程序都应创建通知，以便向用户提供信息，而不是直接启动活动。一些特殊情况如：来电或者警报，需要立刻启动 Activity，则可以通过创建高优先级的通知，并提供 fullscreen itent。如何创建高优先级通知？ 设备位置权限的访问控制用户可以更好地控制应用何时可以访问设备位置。当在Android Q上运行的应用程序请求位置访问时，会通过对话框的形式给用户进行授权提示。此对话框允许用户授予对两个不同范围的位置访问权限：在使用中（仅限前台）或始终（前台和后台）。新增权限 ACCESS_BACKGROUND_LOCATION如果你的应用针对 Android Q 并且需要在后台运行时访问用户的位置，则必须在应用的清单文件中声明新权限 位置限制的兼容性如果您的应用在 Android Q 上运行但针对的是 Android 9（API级别28）或更低版本，则会出现以下行为：如果你的应用为 ACCESS_FINE_LOCATION 或 ACCESS_COARSE_LOCATION 声明 标记，则系统会在安装期间自动为ACCESS_BACKGROUND_LOCATION 添加 标记。如果你的应用请求 ACCESS_FINE_LOCATION 或 ACCESS_COARSE_LOCATION，系统会自动将 ACCESS_BACKGROUND_LOCATION添加到请求中。虽然你的应用可以请求并接收 ACCESS_BACKGROUND_LOCATION，但用户可以通过选择您的应用仅应在前台访问位置信息来撤消此权限。 允许应用程序降级。当对商店更新后的版本后悔时，可以“回到过去”即回滚到旧版。 对数据和标识符的更改影响在Android Q 上运行的所有应用的更改： 联系人亲缘关系 从Android Q开始，该平台不再跟踪联系人关系信息。因此，如果您的应用对用户的联系人进行搜索，则结果不再按交互频率排序。“联系人提供程序”指南包含一个通知，说明自Android Q起所有设备上已废弃的特定字段和方法。 MAC地址随机化 在Android Q 运行的设备默认传输随机的MAC 地址，获取随机MAC地址API：WifiConfiguration.getRandomizedMacAddress()，获取实际硬件MAC地址：WifiInfo.getFactoryMacAddress()。 唯一标识符 应用必须具有 READ_PRIVILEGED_PHONE_STATE 特权权限才能访问设备的不可重置标识符，包括IMEI和序列号。原则上 Android Q 建议避免使用更容易关联到个人的硬件标识符，而是使用实例ID。实例ID的做法推荐 访问剪贴板数据 除非您的应用程序是默认输入法编辑器或当前具有焦点的应用程序，否则您的应用程序无法访问剪贴板数据。 影响针对 Android Q API 级别运行的应用的更改： 访问USB串行需要用户许可 如果您的应用针对Android Q，则您的应用只能在用户授予您访问USB设备或配件的应用权限后才能读取序列号。 相机和连接相关更改 影响在Android Q 上运行的所有应用的更改： 访问相机信息需要获得许可 Android Q更改了默认情况下getCameraCharacteristics（）方法返回的信息的广度。特别是，您的应用必须具有CAMERA权限才能访问此方法的返回值中包含的潜在设备特定元数据。 启用和禁用Wi-Fi的限制 在Android Q上运行的应用无法启用或停用Wi-Fi。WifiManager.setWifiEnabled（）方法始终返回false。如果需要，请使用设置面板提示用户启用和禁用Wi-Fi。 电话，Wi-Fi，蓝牙API所需的精确位置许可 除非您的应用具有ACCESS_FINE_LOCATION权限，否则在Android Q上运行时，您的应用无法在Wi-Fi，Wi-Fi Aware或蓝牙API中使用多种方法。要查看受影响方法的列表，请参阅隐私附录。 Wi-Fi网络配置限制 将Wi-Fi网络列表的手动配置限制在系统应用程序中。如果您的应用针对Android Q，则以下方法不再返回有用数据,下面方法将不会返回有效信息： * getConfiguredNetworks（）方法始终返回空List; * addNetwork（）和updateNetwork（） - 始终返回-1 #返回布尔值的每个网络操作 - removeNetwork（），reassociate（），enableNetwork（），disableNetwork（），reconnect（）和disconnect（） - 始终返回false * 物理活动识别 针对 Android Q API 级别运行的应用，Android Q为需要检测用户移动的应用程序（例如步行，骑自行车或车辆）引入了新的ACTIVITY_RECOGNITION运行时权限。这旨在让用户了解设置中如何使用设备传感器数据。 Android Q 行为变更最令我们关心的，还是我们的适配工作。下面，分两部分讲： 一、针对所有运行在 Android Q 上的app的行为变更非SDK接口限制更新（Non-SDK interface restrictions）：为了确保应用稳定性和兼容性，Google 在 Android O 中开始限制使用哪些非SDK接口（API级别28）。Android Q 更新了非SDK接口的限制列表，并且修改了限制规则。 灰名单修改：在Android 9（API级别28）中，灰名单分为以下两个列表：（1）lightgrey列表: targetSdkVersion&lt;28 情况下可以使用的非SDK接口（2）darkgrey list：targetSdkVersion&gt;=28 情况下无法使用的非SDK接口在 Android Q 中，我们现在将这两个列表统称为 greylist（灰名单），但是受目标API级别限制：如在 Android P 中被限制的黑灰色名单：darkgrey list 现在叫做 greylist-max-o，在 Android Q 中被限制的非SDK接口应该称为 greylist-max-p 代码注释修改：引入以下注解来区别哪些非SDK接口在哪个API做了限制@UnsupportedAppUsge 无限制的灰名单@UnsupportedAppUsage(maxTargetSdk = 0) 黑名单，哪个API都不能调用@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.O) API &lt;= Android O 可以调用@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P) API &lt;= Android P 可以调用Android Q 非SDK接口限制列表过长，这里直接附上查询地址WIFI P2P 广播（Wi-Fi Direct broadcasts）：在 Android Q 上，与 Wi-Fi Direct 功能相关的广播不再具有粘性。如果你的 APP 依赖于在注册时接收这些广播，可以在初始化时使用适当的get（）方法来获取信息，具体可参考 WifiP2pManager 类相关方法。SYSTEM_ALERT_WINDOW 权限在 Android Go 设备变更在Android Q（Go版）设备上运行的应用无法接收SYSTEM_ALERT_WINDOW权限。这是因为绘制叠加窗口使用过多的内存，这对低内存Android设备的性能特别有害。 二、针对API级别为 Android Q 的行为变更如果你的应用将targetSdkVersion设置为“android-Q”或更高版本，则下面的你需要注意了。 灰名单变更灰名单变更参考“针对所有运行在 Android Q 上的app的行为变更”的策略，意味着@UnsupportedAppUsage(maxTargetSdk &lt; Build.VERSION_CODES.Q) 的非API方法你都需要注意了！！！ 共享内存针对Q的应用不能再直接使用ashmem（/ dev / ashmem），而必须通过NDK的ASharedMemory类访问共享内存。此外，应用程序无法直接对现有的ashmem文件描述符进行IOCTL，而必须使用NDK的ASharedMemory类或Android Java API来创建共享内存区域。在使用共享内存时，此更改可提高安全性和稳健性，从而提高Android整体的性能和安全性。 Android runtime only accepts system-generated OAT filesAndroid运行时（ART）不再从应用程序进程调用dex2oat。此更改意味着ART将仅接受系统生成的OAT文件。 Permissions changes for fullscreen intents使用全屏Intent通知的应用必须在其应用的 Manifest 文件中请求 USE_FULL_SCREEN_INTENT 权限，这是正常权限，因此系统会自动授予。如果针对Android Q或更高版本的应用尝试在不请求USE_FULL_SCREEN_INTENT权限的情况下创建具有全屏的Intent，系统将忽略全屏意图。","link":"/2019/08/08/Android versions newfeature/"}],"tags":[{"name":"test","slug":"test","link":"/tags/test/"},{"name":"demo","slug":"demo","link":"/tags/demo/"},{"name":"hexo; github","slug":"hexo-github","link":"/tags/hexo-github/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"handler","slug":"handler","link":"/tags/handler/"},{"name":"tool","slug":"tool","link":"/tags/tool/"},{"name":"android; aosp","slug":"android-aosp","link":"/tags/android-aosp/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"aosp","slug":"aosp","link":"/tags/aosp/"}],"categories":[{"name":"test","slug":"test","link":"/categories/test/"},{"name":"tools","slug":"tools","link":"/categories/tools/"},{"name":"android","slug":"android","link":"/categories/android/"}]}